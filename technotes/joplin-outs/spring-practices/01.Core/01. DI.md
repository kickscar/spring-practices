01. DI

## 빈 와이어링(Bean Wiring)

 객체(빈) 간의 연관관계, 주로 의존관계에서 종속 관계가 있는 객체의 주입(DI)을 보통 빈 와이어링이라 부른다. 스프링 컨테이너의 가장 기본적인 기능으로 스프링 기반 애플리케이션 대부분이 이 기능을 이용하여 애플리케이션 설정 및 구성을 하게된다. 따라서 스프링을 사용하기 위해서는 필수로 익혀야 하는 기본 테크닉이다. 문제는 스프링 컨테이너가 다양한 와이어링 방법을 제공하는 데서 오는 혼동과 복잡함이다. 이해가 우선이기 때문에 일단 나누어 보자. 

1.	자동 와이어링(Automatic Wiring)
2.	명시적 와이어링(Explitcit Wiring)

 크게는 이 두가지로 나누어 볼 수 있다. 그리고 다시 각각의 방법들은

1.	Java Class를 사용하는 방법(Java Class Configuration)
2.	XML을 사용하는 방법(XML Configuration)

 으로 다시 나누어 질 수 있다. 따라서 대략 네 가지의 개별적 방법들을 이해하고 상황에 따라 믹싱하면 된다.

## 선택 기준
 네 가지 방법 중 어떤 것이 좋다 또는 나쁘다 판단할 근거는 없어 보인다. 왜냐하면 모든 방법들이 모두 장단점을 나름 가지고 있기 때문이다. 상황에 맞게 자동 설정을 하기도 하고 자동 설정이 불가능하면 명시적 설정을 하면 된다. 명시적 설정에서는 Java 설정을 많이 선호한다. 하지만, 설정 코드가 복잡하고 불가능한 것은 표현이 풍부한 XML로 표현하는 것도 나쁘지 않다.
 
 레거시가 XML로 설정되어 있는 경우에 굳이 Java 설정으로 바꾸려 하지 않았던 경험이 있는데 XML 설정이 완벽히 Java 설정으로 전환되는 것도 아니고 변경에 대한 부담도 상당히 크기 때문이었다. 결론은 각자 선호하는 방법으로 새로운 개발에 적용할 수 있을 지 모르겠지만, 레거시를 다루고 자바 개발이 많은 외부 라이브러리에 의존하기 때문에 모든 설정 방법을 다 잘 알고 있어야 한다는 것이다. 규모 있는 실무 개발에서는 네 가지 방법이 선택적으로 믹싱되어 있는 경우가 대부분인 것도 그 이유이다.


## 자동 와이어링(Automatic Wiring)
 <a href="https://github.com/kickscar/spring-inspects/tree/master/scan" target="_blank">컴포넌트 스캐닝 기술을 기반으로 자동으로 빈 생성과 와이어링</a>을 한다. 클래스에 @Component 어노테이션을 달면 클래스 스캐닝을 통해 빈 생성이 가능하다. DI가 필요한 필드에는 @Autowired 어노테이션을 달면, 주입이 자동으로 된다. 스캐닝을 활성화 시키는 아주 간단한 설정 정도만 XML 또는 Java로 한다.
 
 명시적인 부분을 많이 생략 할 수 있기 때문에 장점이 많은 방법이다. 하지만 스캐닝으로 인식이 가능한 어노테이션이 달려 있어야 하는 조건 때문에 한계도 많다. 직접 작성하는 코드에는 어노테이션을 달 수 있겠지만, 당연히 많은 스프링 서드 파티 프레임워크나 자바 라이브러리에는 달려있지 않을 것이기 때문이다. 이런 이유로 명시적인 설정이 필요하다. 그리고 빈 생성과 DI 정도만 자동으로 되기때문에 정밀한 빈 생성과 설정을 위해서는 명시적 설정을 할 수 밖에 없다.

## Java Class Configuration

1.	@Component 스캐닝과 Java Configuration 클래스

2.	@Autowired, @Inject 을 이용한 DI
	@Autowired와 @Inject 차이

3.	다양한 DI 방법

1.  필드 주입 \- CDPlayerEx01.java
2.  생성자 주입 \- CDPlayerEx02.java
3.  setter 메소드 주입 - CDPlayerEx03.java
4.  일반 메소드 주입 \- CDPlayerEx04.java

#### 2.4 \[실습\] ch02-ex04 : @Qualifier, @Named, @Primary 용도


## XML Configuration


## 명시적 와이어링(Explicit Wiring)
 명시적 와이어링(Explicit Wiring)이라기 보다는 명시적 설정(Explicit Configuration)이라고 보통 부른다. 이유는 앞의 자동 와이어링과 다르게 생성 빈에 대한 선언 또는 명시를 자바 설정에서는 코드로 그리고 XML 설정에서는 &lt;bean /&gt;태그로 설정을 분명하게 해야 하기 때문이다. 사람에 따라서는 자동 설정을 추천한다. 물론 할 수 있다면 하는 것이 좋지만 앞에서 언급한대로 그렇지 못한 경우가 많다.
 
 코드 또는 태깅 설정이 장황하고 귀챦을 수 있다. 하지만 설정을 통해 애플리케이션의 구성 컴포넌트들의 설계도 또는 조립도 같은 개념을 가질 수 있기 때문에 애플리케이션 이해와 구성이 명확하다는 것이 장점이다. 명시적 설정에서는 Java 설정을 선호하는 편이다. 이유는 타입 세이프, 설정 오류를 런타임이 아닌 개발시 발견할 수 있는 장점 때문이다. 하지만, XML 설정은 표현이 아무래도 Java 코드보다 좋기 때문에 Java 설정으로 하지 못하는 경우에는 XML 설정을 해야 하는 경우도 있다.  

## Java Class Configuration

#### 2.1 \[실습\] ch02-ex06 : @Bean 어노테이션을 이용한 빈 설정

#### 2.2 \[실습\] ch02-ex07 : 같은 타입의 빈 DI 하기

#### 2.3 \[실습\] ch02-ex08 : 다양한 DI 방법

1.  생성자 주입 : Bean 생성 메소드 직접 호출
2.  생성자 주입 : Bean 생성 메소드의 파라미터 전달
3.  setter 주입 : Bean 생성 메소드 직접 호출
4.  setter 주입 : Bean 생성 메소드의 파라미터 전달

## XML Configuration

#### 3.1 \[실습\] ch02-ex09 : &lt;bean /&gt; 태그를 이용한 빈 설정

#### 3.2 \[실습\] ch02-ex10 : 설정된 빈에 id, name 부여하기

1.  기본 id
2.  id와 name의 차이점

#### 3.3 \[실습\] ch02-ex11 : 다양한 생성자 설정

1.  &lt;contructor-arg /&gt; 태그 사용해서 생성자에 파라미터 전달하기
2.  &lt;contructor-arg /&gt; 태그의 index 속성
3.  &lt;contructor-arg /&gt; 태그의 name 속성
4.  c: namspace 필드이름 리터럴 속성
5.  c: namspace _index 속성
6.  &lt;contructor-arg /&gt; 태그를 사용하여 생성자 파라피터에 null 전달하기
7.  &lt;contructor-arg /&gt; 태그의 생성자 값콜렉션 파라미터 전달
8.  c: namspace 필드이름 리터럴 속성과 util-namespace를 사용한 생성자 값콜렉션 파라미터 전달
9.  &lt;contructor-arg /&gt; 태그의 생성자 빈콜렉션 파라미터 전달
10. c: namspace 필드이름 리터럴 속성과 util-namespace를 사용한 생성자 빈콜렉션 파라미터 전달

#### 3.4 \[실습\] ch02-ex12 : 다양한 setter 설정

1.  &lt;property /&gt; 태그 사용해서 빈 초기화 하기
2.  p: namespace 필드이름 리터럴을 사용하여 빈 초기화 하기
3.  값콜렉션 필드 초기화하는 2가지 방법
4.  빈콜렉션 필드 초기화하는 2가지 방법

#### 3.5 \[실습\] ch02-ex13 : 생성자를 통한 DI

1.  &lt;contructor-arg /&gt; 태그의 ref 속성을 사용하여 주입하기
2.  c: namspace 필드이름-ref 리터럴을 사용하여 주입하기
3.  c: namspace _index-ref 을 사용하여 주입하기

#### 3.6 \[실습\] ch02-ex14 : setter를 통한 DI

1.  &lt;property /&gt; 태그의 ref 속성을 사용하여 주입하기
2.  p: namspace 필드이름-ref 리터럴을 사용하여 주입하기